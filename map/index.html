<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Trans-Time • Маршрут для грузовиков</title>
<style>
:root {
  color-scheme: dark;
  --bg:#0f1115;
  --panel:#151822;
  --panel-soft:rgba(21,24,34,.92);
  --text:#e6eaf2;
  --muted:#8d96aa;
  --accent:#e11d2e;
  --frame:#60a5fa;
  --alt:#f59e0b;
  --success:#22c55e;
  --stroke:#232836;
  --btn:#1b2030;
  --btn-hover:#232a36;
  --btn-active:#2a3142;
  --shadow:0 18px 48px rgba(0,0,0,.45);
  --radius-lg:16px;
  --radius-md:12px;
  --radius-sm:10px;
  --header-height:88px;
  --page-pad:clamp(16px,4vw,32px);
  --content-gap:clamp(18px,4vw,32px);
}
* { box-sizing:border-box; }
html,body { height:100%; margin:0; }
body {
  background:var(--bg);
  color:var(--text);
  font:14px/1.45 "Inter",system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
  display:flex;
  flex-direction:column;
  min-height:100vh;
  -webkit-font-smoothing:antialiased;
}
a { color:inherit; }
button,input { font:inherit; color:inherit; }
button { cursor:pointer; }
body.is-grabbing, body.is-grabbing * { cursor:grabbing!important; }
#app { display:flex; flex-direction:column; flex:1; min-height:0; }
header {
  position:sticky;
  top:0;
  z-index:20;
  background:linear-gradient(180deg,rgba(21,24,34,.98),rgba(15,17,21,.88));
  border-bottom:1px solid var(--stroke);
  backdrop-filter:blur(10px);
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.bar {
  max-width:1280px;
  margin:0 auto;
  padding:18px clamp(16px,3vw,32px) 20px;
  display:flex;
  flex-direction:column;
  gap:18px;
}
.bar-top {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  flex-wrap:wrap;
}
.brand {
  display:flex;
  align-items:center;
  gap:12px;
  font-weight:600;
  letter-spacing:.02em;
  font-size:17px;
}
.brand img { width:32px; height:32px; }
.brand span { white-space:nowrap; }
.small-note { color:var(--muted); font-size:12px; }
.controls { display:flex; flex-direction:column; gap:14px; }
.fields {
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:12px;
}
.field {
  background:var(--btn);
  border:1px solid var(--stroke);
  border-radius:var(--radius-lg);
  padding:10px 14px;
  display:flex;
  flex-direction:column;
  gap:6px;
  min-width:0;
}
.field label {
  font-size:11px;
  text-transform:uppercase;
  letter-spacing:.09em;
  color:var(--muted);
}
.field .input-wrap {
  display:flex;
  align-items:center;
  gap:10px;
}
.field input {
  flex:1;
  border:0;
  background:transparent;
  min-height:44px;
  padding:0;
  outline:none;
}
.field input::placeholder { color:rgba(230,234,242,.55); }
.field input:focus-visible { outline:none; }
.veh-actions {
  display:flex;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
  align-items:stretch;
}
#vehicleGroup {
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.pill {
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:10px 16px;
  border-radius:999px;
  border:1px solid var(--stroke);
  background:var(--btn);
  font-weight:600;
  letter-spacing:.01em;
  transition:background .2s ease,border-color .2s ease,color .2s ease;
}
.pill input { display:none; }
.pill.active { background:var(--btn-hover); border-color:var(--accent); color:#fff; }
.actions {
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
  grid-auto-rows:minmax(48px,auto);
  gap:10px;
  flex:1;
  position:relative;
}
.actions button {
  min-height:48px;
  border-radius:var(--radius-md);
  border:1px solid transparent;
  background:var(--btn);
  color:var(--text);
  font-weight:600;
  letter-spacing:.01em;
  transition:background .18s ease,border-color .18s ease,transform .18s ease,color .18s ease;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:0 16px;
  text-align:center;
}
.actions button.primary {
  background:var(--accent);
  border-color:var(--accent);
  color:#fff;
}
.actions button.secondary {
  border-color:var(--stroke);
}
.actions button:hover:not(:disabled),
.actions button:focus-visible {
  background:var(--btn-hover);
  border-color:rgba(225,29,46,.45);
  outline:none;
}
.actions button.primary:hover:not(:disabled),
.actions button.primary:focus-visible {
  background:#f02c3e;
  border-color:#f02c3e;
}
.actions button:active:not(:disabled) { transform:translateY(1px); }
.actions button:disabled { opacity:.55; cursor:not-allowed; }
.actions button .icon {
  font-size:18px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:1.4em;
}
.actions button .label {
  white-space:nowrap;
}
.actions button.is-busy .icon {
  opacity:.8;
}
.actions button.is-busy {
  cursor:wait;
}
button:focus-visible,
input:focus-visible {
  outline:2px solid rgba(96,165,250,.45);
  outline-offset:2px;
}
.options-panel {
  position:absolute;
  right:0;
  top:calc(100% + 12px);
  padding:14px 16px;
  background:var(--panel-soft);
  border:1px solid var(--stroke);
  border-radius:var(--radius-lg);
  box-shadow:var(--shadow);
  min-width:220px;
  display:none;
  flex-direction:column;
  gap:12px;
  z-index:30;
}
.options-panel.show { display:flex; animation:fadeSlide .22s ease-out; }
.option-item {
  display:flex;
  align-items:center;
  gap:12px;
  font-size:13px;
}
.option-item input[type="checkbox"] {
  appearance:none;
  width:20px;
  height:20px;
  border-radius:6px;
  border:1px solid var(--stroke);
  background:var(--btn);
  position:relative;
  transition:background .18s ease,border-color .18s ease,box-shadow .18s ease;
}
.option-item input[type="checkbox"]:checked {
  background:var(--accent);
  border-color:var(--accent);
}
.option-item input[type="checkbox"]:checked::after {
  content:"";
  position:absolute;
  left:4px;
  top:2px;
  width:10px;
  height:14px;
  border:2px solid #fff;
  border-top:0;
  border-left:0;
  transform:rotate(45deg);
}
.option-item input[type="checkbox"]:focus-visible {
  outline:2px solid rgba(96,165,250,.6);
  outline-offset:2px;
}
main {
  flex:1;
  position:relative;
  min-height:calc(100vh - var(--header-height));
  overflow:hidden;
  padding:var(--content-gap) var(--page-pad) var(--page-pad);
}
@media (min-width:1200px) {
  main { min-height:0; }
}
#map {
  position:absolute;
  inset:0;
  background:#050608;
  cursor:grab;
  border-radius:var(--radius-lg);
  border:1px solid var(--stroke);
  box-shadow:var(--shadow);
  overflow:hidden;
}
#routeList {
  position:absolute;
  right:var(--page-pad);
  top:var(--content-gap);
  min-width:240px;
  max-width:320px;
  max-height:calc(100vh - var(--header-height) - var(--content-gap) - var(--page-pad));
  overflow-y:auto;
  padding:14px 16px;
  border-radius:var(--radius-lg);
  border:1px solid var(--stroke);
  background:var(--panel-soft);
  box-shadow:var(--shadow);
  display:none;
  backdrop-filter:blur(10px);
  z-index:15;
}
.routeItem {
  padding:12px;
  border-radius:var(--radius-md);
  border:1px solid transparent;
  cursor:pointer;
  display:flex;
  flex-direction:column;
  gap:6px;
  transition:background .18s ease,border-color .18s ease;
}
.routeItem:hover,
.routeItem:focus-visible {
  background:var(--btn);
  outline:none;
}
.routeItem.active {
  border-color:var(--accent);
  background:rgba(225,29,46,.14);
}
.routeItem .title { font-weight:600; }
.routeItem .meta { color:var(--muted); font-size:12px; }
.legend {
  position:absolute;
  left:var(--page-pad);
  bottom:var(--page-pad);
  display:flex;
  gap:16px;
  align-items:center;
  padding:12px 16px;
  border-radius:var(--radius-lg);
  border:1px solid var(--stroke);
  background:var(--panel-soft);
  box-shadow:var(--shadow);
  font-size:13px;
  z-index:12;
}
.legend .item { display:flex; align-items:center; gap:8px; white-space:nowrap; }
.legend .dot {
  width:12px;
  height:12px;
  border-radius:50%;
  box-shadow:0 0 0 1px rgba(0,0,0,.35);
}
#toast {
  position:fixed;
  right:var(--page-pad);
  bottom:var(--page-pad);
  padding:14px 18px;
  border-radius:var(--radius-lg);
  border:1px solid var(--stroke);
  background:var(--panel-soft);
  color:var(--text);
  box-shadow:var(--shadow);
  max-width:360px;
  display:flex;
  gap:12px;
  opacity:0;
  pointer-events:none;
  transform:translateY(16px);
  transition:opacity .24s ease, transform .24s ease;
  z-index:40;
}
#toast.show {
  opacity:1;
  pointer-events:auto;
  transform:translateY(0);
}
#toast[data-tone="error"] { border-color:#e11d2e; background:rgba(225,29,46,.16); }
#toast[data-tone="success"] { border-color:#22c55e; background:rgba(34,197,94,.16); }
#toast[data-tone="warning"] { border-color:#f59e0b; background:rgba(245,158,11,.16); }
#toast strong { font-weight:600; }
@media (max-width:900px) {
  .fields { grid-template-columns:1fr; }
  .veh-actions { flex-direction:column; align-items:stretch; }
  #vehicleGroup { justify-content:flex-start; }
  .actions {
    grid-template-columns:repeat(2,minmax(0,1fr));
    grid-auto-rows:minmax(48px,auto);
  }
  #routeList {
    left:var(--page-pad);
    right:var(--page-pad);
    top:auto;
    bottom:calc(var(--page-pad) + 72px);
    max-height:45vh;
  }
  #toast {
    left:var(--page-pad);
    right:var(--page-pad);
    bottom:var(--page-pad);
    max-width:none;
  }
  .legend {
    left:var(--page-pad);
    right:auto;
    bottom:calc(var(--page-pad) + 12px);
    flex-wrap:wrap;
    row-gap:10px;
  }
}
@media (max-width:640px) {
  .bar { gap:16px; }
  .actions { grid-template-columns:1fr; }
  .brand span { font-size:15px; }
}
@keyframes fadeSlide {
  from { opacity:0; transform:translateY(-8px); }
  to { opacity:1; transform:translateY(0); }
}
::-webkit-scrollbar { width:8px; height:8px; }
::-webkit-scrollbar-thumb { background:rgba(137,148,172,.55); border-radius:999px; }
::-webkit-scrollbar-track { background:rgba(35,40,54,.6); }
</style>
<script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU&apikey=317aa42d-aa15-4acf-885a-6d6bfddb2339&suggest_apikey=317aa42d-aa15-4acf-885a-6d6bfddb2339" defer></script>
</head>
<body>
<div id="app">
  <header>
    <div class="bar">
      <div class="bar-top">
        <div class="brand">
          <img src="../assets/logo-tt.svg" alt="Trans-Time" loading="lazy" width="32" height="32"/>
          <span>Trans-Time • Маршрут для грузовиков</span>
        </div>
        <div class="small-note">Клик по карте — via‑точка • Альтернативы справа/снизу</div>
      </div>
      <div class="controls">
        <div class="fields">
          <div class="field">
            <label for="from">Откуда</label>
            <div class="input-wrap">
              <input id="from" type="text" placeholder="Начните вводить адрес" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
            </div>
          </div>
          <div class="field">
            <label for="to">Куда</label>
            <div class="input-wrap">
              <input id="to" type="text" placeholder="Начните вводить адрес" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
            </div>
          </div>
        </div>
        <div class="veh-actions">
          <div id="vehicleGroup" role="radiogroup" aria-label="Тип транспорта">
            <label class="pill active"><input type="radio" name="veh" value="car" checked>Легковой</label>
            <label class="pill"><input type="radio" name="veh" value="truck40">≤40 т</label>
            <label class="pill"><input type="radio" name="veh" value="truckHeavy">&gt;40 т</label>
          </div>
          <div class="actions">
            <button id="swapBtn" type="button" class="secondary" aria-label="Поменять местами точки">
              <span class="icon" aria-hidden="true">🔄</span>
              <span class="label">Поменять</span>
            </button>
            <button id="geoBtn" type="button" class="secondary" aria-label="Определить моё местоположение">
              <span class="icon" aria-hidden="true">📍</span>
              <span class="label">Местоположение</span>
            </button>
            <button id="buildBtn" type="button" class="primary">
              <span class="icon" aria-hidden="true">▶</span>
              <span class="label">Построить маршрут</span>
            </button>
            <button id="clearVia" type="button" class="secondary">
              <span class="icon" aria-hidden="true">🗑️</span>
              <span class="label">Сбросить via-точки</span>
            </button>
            <button id="optsBtn" type="button" class="secondary" aria-haspopup="true" aria-expanded="false">
              <span class="icon" aria-hidden="true">☰</span>
              <span class="label">Опции</span>
            </button>
            <div id="optionsPanel" class="options-panel" role="dialog" aria-modal="false" aria-labelledby="optsBtn">
              <label class="option-item"><input id="toggleFrames" type="checkbox" checked/> Показывать весовые рамки</label>
              <label class="option-item"><input id="toggleDetour" type="checkbox"/> Авто-объезд рамок</label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>
  <main>
    <div id="map" role="application" aria-label="Карта маршрутов"></div>
    <div id="routeList" aria-live="polite"></div>
    <div class="legend">
      <div class="item"><span class="dot" style="background:var(--success);"></span> Активный маршрут</div>
      <div class="item"><span class="dot" style="background:var(--alt);"></span> Альтернативы</div>
      <div class="item"><span class="dot" style="background:var(--frame);"></span> Весовые рамки</div>
    </div>
  </main>
</div>
<div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>
<script>
(function(){
  'use strict';

  let map, multiRoute, objectManager;
  const userViaPoints = [];
  const userViaMarks = [];
  let framePoints = [];
  let pendingDetours = [];
  let announceDetoursOnce = false;
  let framesOnMap = false;
  let optionsOpen = false;
  let autoDetourEnabled = false;
  let showFrames = true;

  const $ = (selector, ctx = document) => ctx.querySelector(selector);
  const $$ = (selector, ctx = document) => Array.from(ctx.querySelectorAll(selector));

  const fromInput = $('#from');
  const toInput = $('#to');
  const routeListEl = $('#routeList');
  const toastEl = $('#toast');
  const locateBtn = $('#geoBtn');
  const swapBtn = $('#swapBtn');
  const clearViaBtn = $('#clearVia');
  const buildBtn = $('#buildBtn');
  const optionsBtn = $('#optsBtn');
  const optionsPanel = $('#optionsPanel');
  const framesCheckbox = $('#toggleFrames');
  const autoDetourCheckbox = $('#toggleDetour');
  const headerEl = document.querySelector('header');
  const locateBtnIcon = locateBtn ? locateBtn.querySelector('.icon') : null;
  const locateBtnLabel = locateBtn ? locateBtn.querySelector('.label') : null;
  const locateBtnDefaultIcon = locateBtnIcon ? locateBtnIcon.textContent.trim() : '';
  const locateBtnDefaultLabel = locateBtnLabel ? locateBtnLabel.textContent.trim() : (locateBtn ? locateBtn.textContent.trim() : '');

  const updateLayoutMetrics = () => {
    if(!headerEl || !document.documentElement) return;
    const height = Math.round(headerEl.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--header-height', `${Math.max(72, height)}px`);
  };

  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = window.setTimeout(updateLayoutMetrics, 120);
  }, {passive:true});

  let headerResizeObserver = null;
  if(typeof ResizeObserver === 'function' && headerEl){
    headerResizeObserver = new ResizeObserver(() => updateLayoutMetrics());
    headerResizeObserver.observe(headerEl);
  }

  updateLayoutMetrics();

  const notifications = (() => {
    const queue = [];
    let timer = null;
    let active = false;

    const schedule = () => {
      if(!queue.length){
        active = false;
        toastEl.classList.remove('show');
        toastEl.dataset.tone = 'info';
        return;
      }
      active = true;
      const {html, ms, tone} = queue.shift();
      toastEl.innerHTML = html;
      toastEl.dataset.tone = tone || 'info';
      toastEl.classList.add('show');
      clearTimeout(timer);
      timer = setTimeout(() => {
        toastEl.classList.remove('show');
        timer = setTimeout(schedule, 200);
      }, ms);
    };

    return {
      push(message, ms = 4200, tone = 'info'){
        const html = typeof message === 'string' ? message : String(message ?? '');
        queue.push({html, ms, tone});
        if(!active) schedule();
      },
      clear(){
        queue.length = 0;
        clearTimeout(timer);
        timer = null;
        active = false;
        toastEl.classList.remove('show');
        toastEl.dataset.tone = 'info';
      }
    };
  })();

  const setActivePill = (value) => {
    $$('#vehicleGroup .pill').forEach((pill) => {
      const input = pill.querySelector('input');
      pill.classList.toggle('active', input && input.value === value && input.checked);
    });
  };

  const getVehicleValue = () => document.querySelector('input[name="veh"]:checked')?.value || 'car';

  const getRoutingConfig = () => {
    const value = getVehicleValue();
    if(value === 'car') return {mode:'auto'};
    if(value === 'truck40') return {mode:'truck', truck:{weight:40000}};
    return {mode:'truck', truck:{weight:50000, axleCount:5}};
  };

  const fmtDist = (m = 0) => {
    if(!Number.isFinite(m) || m <= 0) return '—';
    const km = m / 1000;
    const precision = km >= 100 ? 0 : 1;
    return km.toFixed(precision).replace('.', ',') + ' км';
  };

  const fmtTime = (s = 0) => {
    if(!Number.isFinite(s) || s <= 0) return '—';
    const hours = Math.floor(s / 3600);
    const minutes = Math.round((s % 3600) / 60);
    if(minutes === 60){
      return `${hours + 1} ч 0 мин`;
    }
    return hours ? `${hours} ч ${minutes} мин` : `${minutes} мин`;
  };

  const escapeHtml = (str) => String(str ?? '').replace(/[&<>"']/g, (ch) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  }[ch]));

  const setLocateBusy = (busy) => {
    if(!locateBtn) return;
    const isBusy = !!busy;
    locateBtn.disabled = isBusy;
    locateBtn.classList.toggle('is-busy', isBusy);
    if(locateBtnIcon){
      locateBtnIcon.textContent = isBusy ? '⏳' : (locateBtnDefaultIcon || '📍');
    }
    if(locateBtnLabel){
      locateBtnLabel.textContent = isBusy ? 'Определяем…' : locateBtnDefaultLabel;
    } else if(locateBtn){
      locateBtn.textContent = isBusy ? '⏳ Определяем…' : locateBtnDefaultLabel;
    }
  };

  function locateUser(){
    if(!navigator.geolocation){
      notifications.push('Геолокация не поддерживается в этом браузере.', 4600, 'warning');
      return;
    }
    setLocateBusy(true);
    navigator.geolocation.getCurrentPosition(async (position) => {
      try {
        const coords = [position.coords.latitude, position.coords.longitude];
        if(map){
          map.setCenter(coords, Math.max(map.getZoom(), 12), {duration:300});
        }
        const result = await ymaps.geocode(coords, {results:1});
        const geoObject = result.geoObjects.get(0);
        const address = geoObject ? (typeof geoObject.getAddressLine === 'function' ? geoObject.getAddressLine() : geoObject.properties.get('text') || geoObject.properties.get('name')) : '';
        if(address){
          fromInput.value = address;
          notifications.push(`📍 <strong>Откуда:</strong> ${escapeHtml(address)}`, 5600, 'success');
          if(toInput.value.trim()){
            buildRoute();
          }
        } else {
          notifications.push('Не удалось определить адрес по координатам.', 5200, 'error');
        }
      } catch (error) {
        console.warn(error);
        notifications.push('Не удалось определить адрес по координатам.', 5200, 'error');
      } finally {
        setLocateBusy(false);
      }
    }, (error) => {
      console.warn(error);
      setLocateBusy(false);
      let message = 'Не удалось получить геолокацию.';
      if(error && typeof error.code === 'number'){
        if(error.code === error.PERMISSION_DENIED){ message = 'Геолокация отклонена пользователем.'; }
        else if(error.code === error.POSITION_UNAVAILABLE){ message = 'Данные геолокации недоступны.'; }
        else if(error.code === error.TIMEOUT){ message = 'Превышено время ожидания геолокации.'; }
      }
      notifications.push(escapeHtml(message), 5200, 'error');
    }, { enableHighAccuracy:true, timeout:15000, maximumAge:60000 });
  }

  function toggleOptions(force){
    optionsOpen = typeof force === 'boolean' ? force : !optionsOpen;
    if(optionsPanel){
      optionsPanel.classList.toggle('show', optionsOpen);
    }
    if(optionsBtn){
      optionsBtn.setAttribute('aria-expanded', optionsOpen ? 'true' : 'false');
    }
    updateLayoutMetrics();
  }

  function applyFrameVisibility(){
    if(!map || !objectManager) return;
    if(showFrames && !framesOnMap){
      map.geoObjects.add(objectManager);
      framesOnMap = true;
    }
    if(!showFrames && framesOnMap){
      map.geoObjects.remove(objectManager);
      framesOnMap = false;
    }
  }

  ymaps.ready(init);

  function init(){
    map = new ymaps.Map('map', {
      center:[55.751244,37.618423],
      zoom:8,
      controls:['zoomControl','geolocationControl','typeSelector','fullscreenControl']
    }, {
      suppressMapOpenBlock:true
    });

    if(map && map.cursors){
      map.cursors.push('grab');
    }
    map.events.add('actionbegin', (e) => {
      if(e.get('type') === 'drag'){
        document.body.classList.add('is-grabbing');
      }
    });
    map.events.add('actionend', () => document.body.classList.remove('is-grabbing'));
    document.addEventListener('mouseup', () => document.body.classList.remove('is-grabbing'));

    const suggestConfig = {
      results:8,
      minChars:1,
      width:'auto'
    };
    const suggestFrom = new ymaps.SuggestView('from', suggestConfig);
    const suggestTo = new ymaps.SuggestView('to', suggestConfig);

    suggestFrom.events.add('select', () => { tryAutoBuild(); });
    suggestTo.events.add('select', () => { tryAutoBuild(); });

    $$('#vehicleGroup input[name="veh"]').forEach((input) => {
      input.addEventListener('change', () => {
        setActivePill(input.value);
        if(fromInput.value.trim() && toInput.value.trim()){
          buildRoute();
        }
      });
    });

    map.events.add('click', (event) => {
      const coords = event.get('coords');
      if(!coords) return;
      const label = `${coords[0].toFixed(6)}, ${coords[1].toFixed(6)}`;
      if(window.confirm(`Добавить via-точку?\n${label}`)){
        userViaPoints.push(coords);
        const mark = new ymaps.Placemark(coords, {hintContent:'via-точка'}, {preset:'islands#blueCircleIcon', iconColor:'#60a5fa'});
        userViaMarks.push(mark);
        map.geoObjects.add(mark);
        notifications.push('Добавлена via-точка', 3600, 'success');
        if(fromInput.value.trim() && toInput.value.trim()){
          buildRoute();
        }
      }
    });

    if(buildBtn){
      buildBtn.addEventListener('click', buildRoute);
    }
    if(locateBtn){
      locateBtn.addEventListener('click', locateUser);
    }
    if(swapBtn){
      swapBtn.addEventListener('click', () => {
        const fromVal = fromInput.value;
        fromInput.value = toInput.value;
        toInput.value = fromVal;
        if(fromInput.value.trim() && toInput.value.trim()){
          buildRoute();
        }
      });
    }
    if(clearViaBtn){
      clearViaBtn.addEventListener('click', () => {
        userViaPoints.length = 0;
        while(userViaMarks.length){
          const placemark = userViaMarks.pop();
          if(placemark){
            map.geoObjects.remove(placemark);
          }
        }
        notifications.push('Via-точки очищены', 3200, 'info');
        if(multiRoute){
          buildRoute();
        }
      });
    }
    if(optionsBtn){
      optionsBtn.addEventListener('click', () => {
        toggleOptions();
      });
    }
    document.addEventListener('click', (event) => {
      if(!optionsOpen) return;
      const clickInsidePanel = optionsPanel && optionsPanel.contains(event.target);
      const clickOnButton = optionsBtn && optionsBtn.contains(event.target);
      if(clickInsidePanel || clickOnButton) return;
      toggleOptions(false);
    }, true);
    document.addEventListener('keydown', (event) => {
      if(event.key === 'Escape' && optionsOpen){
        toggleOptions(false);
      }
    });
    if(framesCheckbox){
      framesCheckbox.addEventListener('change', () => {
        showFrames = framesCheckbox.checked;
        applyFrameVisibility();
        notifications.push(showFrames ? 'Весовые рамки отображаются.' : 'Весовые рамки скрыты.', 3200, 'info');
      });
    }
    if(autoDetourCheckbox){
      autoDetourCheckbox.addEventListener('change', () => {
        autoDetourEnabled = autoDetourCheckbox.checked;
        notifications.push(autoDetourEnabled ? 'Авто-объезд рамок включён.' : 'Авто-объезд рамок выключен.', 3400, autoDetourEnabled ? 'success' : 'info');
        if(autoDetourEnabled && getVehicleValue() === 'car'){
          notifications.push('Авто-объезд работает только для грузового транспорта.', 4200, 'warning');
        }
        if(fromInput.value.trim() && toInput.value.trim()){
          buildRoute();
        }
      });
    }

    ['from','to'].forEach((id) => {
      const input = document.getElementById(id);
      input.addEventListener('keydown', (event) => {
        if(event.key === 'Enter'){
          event.preventDefault();
          buildRoute();
        }
      });
    });

    function tryAutoBuild(){
      if(fromInput.value.trim() && toInput.value.trim()){
        buildRoute();
      }
    }

    loadFrames();
  }

  async function geocodeToPoint(query){
    if(Array.isArray(query) && query.length === 2) return query;
    const response = await ymaps.geocode(query, {results:1});
    const geoObject = response.geoObjects.get(0);
    if(!geoObject) throw new Error('Адрес не найден: ' + query);
    return geoObject.geometry.getCoordinates();
  }

  async function buildRoute(){
    const fromValue = fromInput.value.trim();
    const toValue = toInput.value.trim();
    if(!fromValue || !toValue){
      notifications.clear();
      notifications.push('Укажи <strong>Откуда</strong> и <strong>Куда</strong>.', 4400, 'warning');
      return;
    }

    try {
      notifications.clear();
      const [start, finish] = await Promise.all([
        geocodeToPoint(fromValue),
        geocodeToPoint(toValue)
      ]);

      let referencePoints = [start, ...userViaPoints, finish];
      pendingDetours = [];
      announceDetoursOnce = false;

      if(autoDetourEnabled && framePoints.length && getVehicleValue() !== 'car' && referencePoints.length >= 2){
        const augmented = injectDetours(referencePoints.slice());
        referencePoints = augmented.points;
        pendingDetours = augmented.names;
        announceDetoursOnce = pendingDetours.length > 0;
      }

      const config = getRoutingConfig();
      const params = {results:3, routingMode:config.mode, avoidTrafficJams:true};
      if(config.truck) params.truck = config.truck;

      if(!multiRoute){
        multiRoute = new ymaps.multiRouter.MultiRoute({
          referencePoints,
          params
        }, {
          boundsAutoApply:true,
          routeActiveStrokeWidth:6,
          routeActiveStrokeColor:'#22c55e',
          routeStrokeStyle:'solid',
          routeStrokeWidth:3,
          routeStrokeOpacity:0.6,
          routeStrokeColor:'#f59e0b',
          wayPointStartIconFillColor:'#22c55e',
          wayPointFinishIconFillColor:'#e11d2e',
          viaPointIconFillColor:'#60a5fa',
          wayPointDraggable:false
        });
        map.geoObjects.add(multiRoute);
        multiRoute.model.events.add('requestsuccess', updateUI);
        multiRoute.events.add('activeroutechange', updateUI);
        multiRoute.model.events.add('requestfail', () => {
          notifications.clear();
          notifications.push('Маршрут не построен. Проверь адреса и тип транспорта.', 5200, 'error');
        });
      } else {
        multiRoute.model.setReferencePoints(referencePoints);
        multiRoute.model.setParams(params, true);
      }

      routeListEl.innerHTML = '<div class="small-note">Строим маршрут…</div>';
      routeListEl.style.display = 'block';
    } catch (error) {
      console.warn(error);
      notifications.clear();
      notifications.push('Не удалось построить маршрут. Проверь адреса.', 5200, 'error');
    }
  }

  function injectDetours(points){
    const projection = ymaps.projection.wgs84Mercator;
    const insertedNames = [];
    for(const frame of framePoints){
      if(!Array.isArray(frame.coords)) continue;
      const nearest = findNearestSegment(points, frame.coords, projection);
      if(!nearest || !isFinite(nearest.distance) || nearest.distance > 100) continue;
      const azimuth = nearest.azimuth;
      const candidates = [azimuth + 90, azimuth - 90];
      let chosen = null;
      let bestSpacing = -Infinity;
      for(const angle of candidates){
        const normalized = normalizeAzimuth(angle);
        const candidate = ymaps.coordSystem.geo.solveDirectProblem(frame.coords, normalized, 200).endPoint;
        const spacing = ymaps.coordSystem.geo.getDistance(candidate, frame.coords);
        if(spacing > bestSpacing){
          bestSpacing = spacing;
          chosen = candidate;
        }
      }
      if(!chosen) continue;
      points.splice(nearest.index + 1, 0, chosen);
      insertedNames.push(frame.name);
    }
    return {points, names:insertedNames};
  }

  function findNearestSegment(points, target, projection){
    if(points.length < 2) return null;
    const targetGlobal = projection.toGlobal(target);
    let best = null;
    for(let i = 0; i < points.length - 1; i++){
      const start = points[i];
      const end = points[i + 1];
      const startGlobal = projection.toGlobal(start);
      const endGlobal = projection.toGlobal(end);
      const vx = endGlobal[0] - startGlobal[0];
      const vy = endGlobal[1] - startGlobal[1];
      const lengthSq = vx * vx + vy * vy;
      if(lengthSq === 0) continue;
      const px = targetGlobal[0] - startGlobal[0];
      const py = targetGlobal[1] - startGlobal[1];
      let t = (px * vx + py * vy) / lengthSq;
      t = Math.max(0, Math.min(1, t));
      const projGlobal = [startGlobal[0] + vx * t, startGlobal[1] + vy * t];
      const projGeo = projection.fromGlobal(projGlobal);
      const distance = ymaps.coordSystem.geo.getDistance(target, projGeo);
      if(!isFinite(distance)) continue;
      if(!best || distance < best.distance){
        const info = ymaps.coordSystem.geo.solveInverseProblem(start, end);
        const azimuth = info.forwardAzimuth;
        best = {distance, index:i, azimuth};
      }
    }
    return best;
  }

  function normalizeAzimuth(value){
    let v = value % 360;
    if(v < 0) v += 360;
    return v;
  }

  function updateUI(){
    if(!multiRoute) return;
    const routes = multiRoute.getRoutes();
    if(!routes || routes.getLength() === 0){
      routeListEl.style.display = 'none';
      notifications.push('Маршрут не найден.', 3800, 'warning');
      return;
    }

    const activeRoute = multiRoute.getActiveRoute();
    if(activeRoute){
      const props = activeRoute.properties.getAll();
      notifications.push(`<strong>Активный маршрут:</strong> ${fmtDist(props?.distance?.value)} • ${fmtTime(props?.duration?.value)}`, 6200, 'info');
      if(announceDetoursOnce && pendingDetours.length){
        const uniqueNames = [...new Set(pendingDetours)].filter(Boolean);
        uniqueNames.forEach((name) => {
          notifications.push(`Объезд весовой рамки у ${escapeHtml(name)}`, 3800, 'warning');
        });
        pendingDetours = [];
        announceDetoursOnce = false;
      }
    }

    routeListEl.innerHTML = '';
    const length = routes.getLength();
    for(let i = 0; i < length; i++){
      const route = routes.get(i);
      const props = route.properties.getAll();
      const item = document.createElement('div');
      const isActive = route === activeRoute;
      item.className = 'routeItem' + (isActive ? ' active' : '');
      item.setAttribute('role', 'button');
      item.setAttribute('tabindex', '0');
      item.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      item.innerHTML = `<div class="title">Вариант ${i + 1}</div><div class="meta">${fmtDist(props?.distance?.value)} • ${fmtTime(props?.duration?.value)}</div>`;
      const activate = () => {
        multiRoute.setActiveRoute(route);
        updateUI();
      };
      item.addEventListener('click', activate);
      item.addEventListener('keydown', (event) => {
        if(event.key === 'Enter' || event.key === ' '){
          event.preventDefault();
          activate();
        }
      });
      routeListEl.appendChild(item);
    }
    routeListEl.style.display = 'block';
  }

  async function loadFrames(){
    try {
      const response = await fetch(`./data/frames_ready.geojson?v=${Date.now()}`, {cache:'no-store'});
      if(!response.ok) throw new Error('frames_ready.geojson not found');
      const data = await response.json();

      if(objectManager && framesOnMap && map){
        map.geoObjects.remove(objectManager);
      }
      objectManager = new ymaps.ObjectManager({clusterize:false, geoObjectOpenBalloonOnClick:true});
      objectManager.objects.options.set({preset:'islands#blueCircleDotIcon', iconColor:'#60a5fa'});

      framePoints = [];
      if(Array.isArray(data?.features)){
        const features = [];
        data.features.forEach((feature, idx) => {
          if(feature?.geometry?.type !== 'Point' || !Array.isArray(feature.geometry.coordinates)) return;
          const [lon, lat] = feature.geometry.coordinates;
          if(!isFinite(lat) || !isFinite(lon)) return;
          const props = feature.properties || {};
          const name = props.name || props.title || props.id || `Рамка №${idx + 1}`;
          const comment = props.comment ? `<div style="margin-top:6px">${escapeHtml(props.comment)}</div>` : '';
          const date = props.date ? `<div class="small-note" style="margin-top:6px;color:#9aa3b2">Дата: ${escapeHtml(props.date)}</div>` : '';
          feature.properties = {
            hintContent:name,
            balloonContent:`<div style="min-width:220px"><strong>${escapeHtml(name)}</strong>${comment}${date}</div>`
          };
          features.push(feature);
          framePoints.push({coords:[lat, lon], name});
        });
        objectManager.add({type:'FeatureCollection', features});
      }

      framesOnMap = false;
      applyFrameVisibility();

      if(framePoints.length){
        notifications.push(`Загружено рамок: ${framePoints.length}`, 3200, 'info');
      } else {
        notifications.push('Нет точек рамок.', 3600, 'warning');
      }
    } catch (error) {
      console.warn(error);
      notifications.push('Не удалось загрузить весовые рамки.', 4800, 'error');
    }
  }
})();
</script>
</body>
</html>
